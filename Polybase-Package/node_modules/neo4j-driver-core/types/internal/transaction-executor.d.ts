<<<<<<< HEAD
/**
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import Transaction from '../transaction';
declare type TransactionCreator = () => Transaction;
declare type TransactionWork<T> = (tx: Transaction) => T | Promise<T>;
declare type Resolve<T> = (value: T | PromiseLike<T>) => void;
declare type Reject = (value: any) => void;
export declare class TransactionExecutor {
    private _maxRetryTimeMs;
    private _initialRetryDelayMs;
    private _multiplier;
    private _jitterFactor;
    private _inFlightTimeoutIds;
    constructor(maxRetryTimeMs?: number | null, initialRetryDelayMs?: number, multiplier?: number, jitterFactor?: number);
    execute<T>(transactionCreator: TransactionCreator, transactionWork: TransactionWork<T>): Promise<T>;
    close(): void;
    _retryTransactionPromise<T>(transactionCreator: TransactionCreator, transactionWork: TransactionWork<T>, error: Error, retryStartTime: number, retryDelayMs: number): Promise<T>;
    _executeTransactionInsidePromise<T>(transactionCreator: TransactionCreator, transactionWork: TransactionWork<T>, resolve: Resolve<T>, reject: Reject): void;
    _safeExecuteTransactionWork<T>(tx: Transaction, transactionWork: TransactionWork<T>): Promise<T>;
    _handleTransactionWorkSuccess<T>(result: T, tx: Transaction, resolve: Resolve<T>, reject: Reject): void;
    _handleTransactionWorkFailure(error: any, tx: Transaction, reject: Reject): void;
=======
/// <reference types="node" />
import Transaction, { NonAutoCommitApiTelemetryConfig, NonAutoCommitTelemetryApis } from '../transaction';
import TransactionPromise from '../transaction-promise';
type TransactionCreator = (apiTransactionConfig?: NonAutoCommitApiTelemetryConfig) => TransactionPromise;
type TransactionWork<T, Tx = Transaction> = (tx: Tx) => T | Promise<T>;
type Resolve<T> = (value: T | PromiseLike<T>) => void;
type Reject = (value: any) => void;
type Timeout = ReturnType<typeof setTimeout>;
type SetTimeout = (callback: (...args: unknown[]) => void, ms: number | undefined, ...args: unknown[]) => Timeout;
type ClearTimeout = (timeoutId: Timeout) => void;
interface Dependencies {
    setTimeout: SetTimeout;
    clearTimeout: ClearTimeout;
}
interface ExecutionContext {
    apiTransactionConfig?: NonAutoCommitApiTelemetryConfig;
}
export declare class TransactionExecutor {
    private readonly _maxRetryTimeMs;
    private readonly _initialRetryDelayMs;
    private readonly _multiplier;
    private readonly _jitterFactor;
    private _inFlightTimeoutIds;
    private readonly _setTimeout;
    private readonly _clearTimeout;
    telemetryApi: NonAutoCommitTelemetryApis;
    pipelineBegin: boolean;
    constructor(maxRetryTimeMs?: number | null, initialRetryDelayMs?: number, multiplier?: number, jitterFactor?: number, dependencies?: Dependencies);
    execute<T, Tx = Transaction>(transactionCreator: TransactionCreator, transactionWork: TransactionWork<T, Tx>, transactionWrapper?: (tx: Transaction) => Tx): Promise<T>;
    close(): void;
    _retryTransactionPromise<T, Tx = Transaction>(transactionCreator: TransactionCreator, transactionWork: TransactionWork<T, Tx>, error: Error, retryStartTime: number, retryDelayMs: number, transactionWrapper?: (tx: Transaction) => Tx, executionContext?: ExecutionContext): Promise<T>;
    _executeTransactionInsidePromise<T, Tx = Transaction>(transactionCreator: TransactionCreator, transactionWork: TransactionWork<T, Tx>, resolve: Resolve<T>, reject: Reject, transactionWrapper?: (tx: Transaction) => Tx, executionContext?: ExecutionContext): Promise<void>;
    _safeExecuteTransactionWork<T, Tx = Transaction>(tx: Tx, transactionWork: TransactionWork<T, Tx>): Promise<T>;
    _handleTransactionWorkSuccess<T>(result: T, tx: Transaction | TransactionPromise, resolve: Resolve<T>, reject: Reject): void;
    _handleTransactionWorkFailure(error: any, tx: Transaction | TransactionPromise, reject: Reject): void;
>>>>>>> library-features
    _computeDelayWithJitter(delayMs: number): number;
    _verifyAfterConstruction(): void;
}
export {};
