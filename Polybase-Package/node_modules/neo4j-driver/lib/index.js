"use strict";
<<<<<<< HEAD

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.driver = driver;
Object.defineProperty(exports, "Driver", {
  enumerable: true,
  get: function get() {
    return _driver.Driver;
  }
});
Object.defineProperty(exports, "Neo4jError", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.Neo4jError;
  }
});
Object.defineProperty(exports, "error", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.error;
  }
});
Object.defineProperty(exports, "Integer", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.Integer;
  }
});
Object.defineProperty(exports, "int", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore["int"];
  }
});
Object.defineProperty(exports, "isInt", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.isInt;
  }
});
Object.defineProperty(exports, "isPoint", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.isPoint;
  }
});
Object.defineProperty(exports, "Point", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.Point;
  }
});
Object.defineProperty(exports, "Date", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.Date;
  }
});
Object.defineProperty(exports, "DateTime", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.DateTime;
  }
});
Object.defineProperty(exports, "Duration", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.Duration;
  }
});
Object.defineProperty(exports, "isDate", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.isDate;
  }
});
Object.defineProperty(exports, "isDateTime", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.isDateTime;
  }
});
Object.defineProperty(exports, "isDuration", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.isDuration;
  }
});
Object.defineProperty(exports, "isLocalDateTime", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.isLocalDateTime;
  }
});
Object.defineProperty(exports, "isLocalTime", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.isLocalTime;
  }
});
Object.defineProperty(exports, "isTime", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.isTime;
  }
});
Object.defineProperty(exports, "LocalDateTime", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.LocalDateTime;
  }
});
Object.defineProperty(exports, "LocalTime", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.LocalTime;
  }
});
Object.defineProperty(exports, "Time", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.Time;
  }
});
Object.defineProperty(exports, "Node", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.Node;
  }
});
Object.defineProperty(exports, "Path", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.Path;
  }
});
Object.defineProperty(exports, "PathSegment", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.PathSegment;
  }
});
Object.defineProperty(exports, "Relationship", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.Relationship;
  }
});
Object.defineProperty(exports, "UnboundRelationship", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.UnboundRelationship;
  }
});
Object.defineProperty(exports, "Record", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.Record;
  }
});
Object.defineProperty(exports, "ResultSummary", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.ResultSummary;
  }
});
Object.defineProperty(exports, "Plan", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.Plan;
  }
});
Object.defineProperty(exports, "ProfiledPlan", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.ProfiledPlan;
  }
});
Object.defineProperty(exports, "QueryStatistics", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.QueryStatistics;
  }
});
Object.defineProperty(exports, "Notification", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.Notification;
  }
});
Object.defineProperty(exports, "ServerInfo", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.ServerInfo;
  }
});
Object.defineProperty(exports, "Result", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.Result;
  }
});
Object.defineProperty(exports, "auth", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.auth;
  }
});
Object.defineProperty(exports, "Session", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.Session;
  }
});
Object.defineProperty(exports, "Transaction", {
  enumerable: true,
  get: function get() {
    return _neo4jDriverCore.Transaction;
  }
});
Object.defineProperty(exports, "RxSession", {
  enumerable: true,
  get: function get() {
    return _sessionRx["default"];
  }
});
Object.defineProperty(exports, "RxTransaction", {
  enumerable: true,
  get: function get() {
    return _transactionRx["default"];
  }
});
Object.defineProperty(exports, "RxResult", {
  enumerable: true,
  get: function get() {
    return _resultRx["default"];
  }
});
exports["default"] = exports.temporal = exports.spatial = exports.session = exports.types = exports.logging = exports.integer = void 0;

var _driver = require("./driver");

var _version = _interopRequireDefault(require("./version"));

var _neo4jDriverCore = require("neo4j-driver-core");

var _neo4jDriverBoltConnection = require("neo4j-driver-bolt-connection");

var _sessionRx = _interopRequireDefault(require("./session-rx"));

var _transactionRx = _interopRequireDefault(require("./transaction-rx"));

var _resultRx = _interopRequireDefault(require("./result-rx"));

/**
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
=======
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnboundRelationship = exports.Relationship = exports.Node = exports.Record = exports.ServerInfo = exports.GqlStatusObject = exports.Notification = exports.QueryStatistics = exports.ProfiledPlan = exports.Plan = exports.ResultSummary = exports.RxResult = exports.RxManagedTransaction = exports.RxTransaction = exports.RxSession = exports.EagerResult = exports.Result = exports.ManagedTransaction = exports.Transaction = exports.Session = exports.Driver = exports.temporal = exports.spatial = exports.graph = exports.error = exports.routing = exports.session = exports.types = exports.logging = exports.auth = exports.isRetryableError = exports.Neo4jError = exports.integer = exports.isUnboundRelationship = exports.isRelationship = exports.isPathSegment = exports.isPath = exports.isNode = exports.isDateTime = exports.isLocalDateTime = exports.isDate = exports.isTime = exports.isLocalTime = exports.isDuration = exports.isPoint = exports.isInt = exports.int = exports.hasReachableServer = exports.driver = exports.authTokenManagers = void 0;
exports.clientCertificateProviders = exports.notificationFilterMinimumSeverityLevel = exports.notificationFilterDisabledClassification = exports.notificationFilterDisabledCategory = exports.notificationSeverityLevel = exports.notificationClassification = exports.notificationCategory = exports.resultTransformers = exports.bookmarkManager = exports.DateTime = exports.LocalDateTime = exports.Date = exports.Time = exports.LocalTime = exports.Duration = exports.Integer = exports.Point = exports.PathSegment = exports.Path = void 0;
/**
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
>>>>>>> library-features
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
<<<<<<< HEAD
var _internal$util = _neo4jDriverCore.internal.util,
    ENCRYPTION_ON = _internal$util.ENCRYPTION_ON,
    ENCRYPTION_OFF = _internal$util.ENCRYPTION_OFF,
    assertString = _internal$util.assertString,
    isEmptyObjectOrNull = _internal$util.isEmptyObjectOrNull,
    ServerAddress = _neo4jDriverCore.internal.serverAddress.ServerAddress,
    urlUtil = _neo4jDriverCore.internal.urlUtil;
=======
var driver_1 = require("./driver");
Object.defineProperty(exports, "Driver", { enumerable: true, get: function () { return driver_1.Driver; } });
var version_1 = __importDefault(require("./version"));
var neo4j_driver_core_1 = require("neo4j-driver-core");
Object.defineProperty(exports, "authTokenManagers", { enumerable: true, get: function () { return neo4j_driver_core_1.authTokenManagers; } });
Object.defineProperty(exports, "Neo4jError", { enumerable: true, get: function () { return neo4j_driver_core_1.Neo4jError; } });
Object.defineProperty(exports, "isRetryableError", { enumerable: true, get: function () { return neo4j_driver_core_1.isRetryableError; } });
Object.defineProperty(exports, "error", { enumerable: true, get: function () { return neo4j_driver_core_1.error; } });
Object.defineProperty(exports, "Integer", { enumerable: true, get: function () { return neo4j_driver_core_1.Integer; } });
Object.defineProperty(exports, "int", { enumerable: true, get: function () { return neo4j_driver_core_1.int; } });
Object.defineProperty(exports, "isInt", { enumerable: true, get: function () { return neo4j_driver_core_1.isInt; } });
Object.defineProperty(exports, "isPoint", { enumerable: true, get: function () { return neo4j_driver_core_1.isPoint; } });
Object.defineProperty(exports, "Point", { enumerable: true, get: function () { return neo4j_driver_core_1.Point; } });
Object.defineProperty(exports, "Date", { enumerable: true, get: function () { return neo4j_driver_core_1.Date; } });
Object.defineProperty(exports, "DateTime", { enumerable: true, get: function () { return neo4j_driver_core_1.DateTime; } });
Object.defineProperty(exports, "Duration", { enumerable: true, get: function () { return neo4j_driver_core_1.Duration; } });
Object.defineProperty(exports, "isDate", { enumerable: true, get: function () { return neo4j_driver_core_1.isDate; } });
Object.defineProperty(exports, "isDateTime", { enumerable: true, get: function () { return neo4j_driver_core_1.isDateTime; } });
Object.defineProperty(exports, "isDuration", { enumerable: true, get: function () { return neo4j_driver_core_1.isDuration; } });
Object.defineProperty(exports, "isLocalDateTime", { enumerable: true, get: function () { return neo4j_driver_core_1.isLocalDateTime; } });
Object.defineProperty(exports, "isLocalTime", { enumerable: true, get: function () { return neo4j_driver_core_1.isLocalTime; } });
Object.defineProperty(exports, "isNode", { enumerable: true, get: function () { return neo4j_driver_core_1.isNode; } });
Object.defineProperty(exports, "isPath", { enumerable: true, get: function () { return neo4j_driver_core_1.isPath; } });
Object.defineProperty(exports, "isPathSegment", { enumerable: true, get: function () { return neo4j_driver_core_1.isPathSegment; } });
Object.defineProperty(exports, "isRelationship", { enumerable: true, get: function () { return neo4j_driver_core_1.isRelationship; } });
Object.defineProperty(exports, "isTime", { enumerable: true, get: function () { return neo4j_driver_core_1.isTime; } });
Object.defineProperty(exports, "isUnboundRelationship", { enumerable: true, get: function () { return neo4j_driver_core_1.isUnboundRelationship; } });
Object.defineProperty(exports, "LocalDateTime", { enumerable: true, get: function () { return neo4j_driver_core_1.LocalDateTime; } });
Object.defineProperty(exports, "LocalTime", { enumerable: true, get: function () { return neo4j_driver_core_1.LocalTime; } });
Object.defineProperty(exports, "Time", { enumerable: true, get: function () { return neo4j_driver_core_1.Time; } });
Object.defineProperty(exports, "Node", { enumerable: true, get: function () { return neo4j_driver_core_1.Node; } });
Object.defineProperty(exports, "Path", { enumerable: true, get: function () { return neo4j_driver_core_1.Path; } });
Object.defineProperty(exports, "PathSegment", { enumerable: true, get: function () { return neo4j_driver_core_1.PathSegment; } });
Object.defineProperty(exports, "Relationship", { enumerable: true, get: function () { return neo4j_driver_core_1.Relationship; } });
Object.defineProperty(exports, "UnboundRelationship", { enumerable: true, get: function () { return neo4j_driver_core_1.UnboundRelationship; } });
Object.defineProperty(exports, "Record", { enumerable: true, get: function () { return neo4j_driver_core_1.Record; } });
Object.defineProperty(exports, "ResultSummary", { enumerable: true, get: function () { return neo4j_driver_core_1.ResultSummary; } });
Object.defineProperty(exports, "Plan", { enumerable: true, get: function () { return neo4j_driver_core_1.Plan; } });
Object.defineProperty(exports, "ProfiledPlan", { enumerable: true, get: function () { return neo4j_driver_core_1.ProfiledPlan; } });
Object.defineProperty(exports, "QueryStatistics", { enumerable: true, get: function () { return neo4j_driver_core_1.QueryStatistics; } });
Object.defineProperty(exports, "Notification", { enumerable: true, get: function () { return neo4j_driver_core_1.Notification; } });
Object.defineProperty(exports, "GqlStatusObject", { enumerable: true, get: function () { return neo4j_driver_core_1.GqlStatusObject; } });
Object.defineProperty(exports, "ServerInfo", { enumerable: true, get: function () { return neo4j_driver_core_1.ServerInfo; } });
Object.defineProperty(exports, "Result", { enumerable: true, get: function () { return neo4j_driver_core_1.Result; } });
Object.defineProperty(exports, "EagerResult", { enumerable: true, get: function () { return neo4j_driver_core_1.EagerResult; } });
Object.defineProperty(exports, "auth", { enumerable: true, get: function () { return neo4j_driver_core_1.auth; } });
Object.defineProperty(exports, "Session", { enumerable: true, get: function () { return neo4j_driver_core_1.Session; } });
Object.defineProperty(exports, "Transaction", { enumerable: true, get: function () { return neo4j_driver_core_1.Transaction; } });
Object.defineProperty(exports, "ManagedTransaction", { enumerable: true, get: function () { return neo4j_driver_core_1.ManagedTransaction; } });
Object.defineProperty(exports, "bookmarkManager", { enumerable: true, get: function () { return neo4j_driver_core_1.bookmarkManager; } });
Object.defineProperty(exports, "routing", { enumerable: true, get: function () { return neo4j_driver_core_1.routing; } });
Object.defineProperty(exports, "resultTransformers", { enumerable: true, get: function () { return neo4j_driver_core_1.resultTransformers; } });
Object.defineProperty(exports, "notificationCategory", { enumerable: true, get: function () { return neo4j_driver_core_1.notificationCategory; } });
Object.defineProperty(exports, "notificationClassification", { enumerable: true, get: function () { return neo4j_driver_core_1.notificationClassification; } });
Object.defineProperty(exports, "notificationSeverityLevel", { enumerable: true, get: function () { return neo4j_driver_core_1.notificationSeverityLevel; } });
Object.defineProperty(exports, "notificationFilterDisabledCategory", { enumerable: true, get: function () { return neo4j_driver_core_1.notificationFilterDisabledCategory; } });
Object.defineProperty(exports, "notificationFilterDisabledClassification", { enumerable: true, get: function () { return neo4j_driver_core_1.notificationFilterDisabledClassification; } });
Object.defineProperty(exports, "notificationFilterMinimumSeverityLevel", { enumerable: true, get: function () { return neo4j_driver_core_1.notificationFilterMinimumSeverityLevel; } });
Object.defineProperty(exports, "clientCertificateProviders", { enumerable: true, get: function () { return neo4j_driver_core_1.clientCertificateProviders; } });
var neo4j_driver_bolt_connection_1 = require("neo4j-driver-bolt-connection");
var session_rx_1 = __importDefault(require("./session-rx"));
exports.RxSession = session_rx_1.default;
var transaction_rx_1 = __importDefault(require("./transaction-rx"));
exports.RxTransaction = transaction_rx_1.default;
var transaction_managed_rx_1 = __importDefault(require("./transaction-managed-rx"));
exports.RxManagedTransaction = transaction_managed_rx_1.default;
var result_rx_1 = __importDefault(require("./result-rx"));
exports.RxResult = result_rx_1.default;
var _a = neo4j_driver_core_1.internal.util, ENCRYPTION_ON = _a.ENCRYPTION_ON, assertString = _a.assertString, isEmptyObjectOrNull = _a.isEmptyObjectOrNull, ServerAddress = neo4j_driver_core_1.internal.serverAddress.ServerAddress, urlUtil = neo4j_driver_core_1.internal.urlUtil;
var USER_AGENT = 'neo4j-javascript/' + version_1.default;
function isAuthTokenManager(value) {
    return typeof value === 'object' &&
        value != null &&
        'getToken' in value &&
        'handleSecurityException' in value &&
        typeof value.getToken === 'function' &&
        typeof value.handleSecurityException === 'function';
}
function createAuthManager(authTokenOrManager) {
    if (isAuthTokenManager(authTokenOrManager)) {
        return authTokenOrManager;
    }
    var authToken = authTokenOrManager;
    // Sanitize authority token. Nicer error from server when a scheme is set.
    authToken = authToken || {};
    authToken.scheme = authToken.scheme || 'none';
    return (0, neo4j_driver_core_1.staticAuthTokenManager)({ authToken: authToken });
}
>>>>>>> library-features
/**
 * Construct a new Neo4j Driver. This is your main entry point for this
 * library.
 *
<<<<<<< HEAD
 * ## Configuration
 *
 * This function optionally takes a configuration argument. Available configuration
 * options are as follows:
 *
 *     {
 *       // Encryption level: ENCRYPTION_ON or ENCRYPTION_OFF.
 *       encrypted: ENCRYPTION_ON|ENCRYPTION_OFF
 *
 *       // Trust strategy to use if encryption is enabled. There is no mode to disable
 *       // trust other than disabling encryption altogether. The reason for
 *       // this is that if you don't know who you are talking to, it is easy for an
 *       // attacker to hijack your encrypted connection, rendering encryption pointless.
 *       //
 *       // TRUST_SYSTEM_CA_SIGNED_CERTIFICATES is the default choice. For NodeJS environments, this
 *       // means that you trust whatever certificates are in the default trusted certificate
 *       // store of the underlying system. For Browser environments, the trusted certificate
 *       // store is usually managed by the browser. Refer to your system or browser documentation
 *       // if you want to explicitly add a certificate as trusted.
 *       //
 *       // TRUST_CUSTOM_CA_SIGNED_CERTIFICATES is another option for trust verification -
 *       // whenever we establish an encrypted connection, we ensure the host is using
 *       // an encryption certificate that is in, or is signed by, a certificate given
 *       // as trusted through configuration. This option is only available for NodeJS environments.
 *       //
 *       // TRUST_ALL_CERTIFICATES means that you trust everything without any verifications
 *       // steps carried out.  This option is only available for NodeJS environments and should not
 *       // be used on production systems.
 *       trust: "TRUST_SYSTEM_CA_SIGNED_CERTIFICATES" | "TRUST_CUSTOM_CA_SIGNED_CERTIFICATES" |
 *       "TRUST_ALL_CERTIFICATES",
 *
 *       // List of one or more paths to trusted encryption certificates. This only
 *       // works in the NodeJS bundle, and only matters if you use "TRUST_CUSTOM_CA_SIGNED_CERTIFICATES".
 *       // The certificate files should be in regular X.509 PEM format.
 *       // For instance, ['./trusted.pem']
 *       trustedCertificates: [],
 *
 *       // The maximum total number of connections allowed to be managed by the connection pool, per host.
 *       // This includes both in-use and idle connections. No maximum connection pool size is imposed
 *       // by default.
 *       maxConnectionPoolSize: 100,
 *
 *       // The maximum allowed lifetime for a pooled connection in milliseconds. Pooled connections older than this
 *       // threshold will be closed and removed from the pool. Such discarding happens during connection acquisition
 *       // so that new session is never backed by an old connection. Setting this option to a low value will cause
 *       // a high connection churn and might result in a performance hit. It is recommended to set maximum lifetime
 *       // to a slightly smaller value than the one configured in network equipment (load balancer, proxy, firewall,
 *       // etc. can also limit maximum connection lifetime). No maximum lifetime limit is imposed by default. Zero
 *       // and negative values result in lifetime not being checked.
 *       maxConnectionLifetime: 60 * 60 * 1000, // 1 hour
 *
 *       // The maximum amount of time to wait to acquire a connection from the pool (to either create a new
 *       // connection or borrow an existing one.
 *       connectionAcquisitionTimeout: 60000, // 1 minute
 *
 *       // Specify the maximum time in milliseconds transactions are allowed to retry via
 *       // `Session#readTransaction()` and `Session#writeTransaction()` functions.
 *       // These functions will retry the given unit of work on `ServiceUnavailable`, `SessionExpired` and transient
 *       // errors with exponential backoff using initial delay of 1 second.
 *       // Default value is 30000 which is 30 seconds.
 *       maxTransactionRetryTime: 30000, // 30 seconds
 *
 *       // Specify socket connection timeout in milliseconds. Numeric values are expected. Negative and zero values
 *       // result in no timeout being applied. Connection establishment will be then bound by the timeout configured
 *       // on the operating system level. Default value is 30000, which is 30 seconds.
 *       connectionTimeout: 30000, // 30 seconds
 *
 *       // Make this driver always return native JavaScript numbers for integer values, instead of the
 *       // dedicated {@link Integer} class. Values that do not fit in native number bit range will be represented as
 *       // `Number.NEGATIVE_INFINITY` or `Number.POSITIVE_INFINITY`.
 *       // **Warning:** ResultSummary It is not always safe to enable this setting when JavaScript applications are not the only ones
 *       // interacting with the database. Stored numbers might in such case be not representable by native
 *       // {@link Number} type and thus driver will return lossy values. This might also happen when data was
 *       // initially imported using neo4j import tool and contained numbers larger than
 *       // `Number.MAX_SAFE_INTEGER`. Driver will then return positive infinity, which is lossy.
 *       // Default value for this option is `false` because native JavaScript numbers might result
 *       // in loss of precision in the general case.
 *       disableLosslessIntegers: false,
 *
 *       // Make this driver always return native Javascript {@link BigInt} for integer values, instead of the dedicated {@link Integer} class or {@link Number}.
 *       //
 *       // Default value for this option is `false` for backwards compatibility.
 *       //
 *       // **Warning:** `BigInt` doesn't implement the method `toJSON`. In maner of serialize it as `json`, It's needed to add a custom implementation of the `toJSON` on the
 *       // `BigInt.prototype` {@see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#use_within_json}
 *       useBigInt: false,
 *
 *       // Specify the logging configuration for the driver. Object should have two properties `level` and `logger`.
 *       //
 *       // Property `level` represents the logging level which should be one of: 'error', 'warn', 'info' or 'debug'. This property is optional and
 *       // its default value is 'info'. Levels have priorities: 'error': 0, 'warn': 1, 'info': 2, 'debug': 3. Enabling a certain level also enables all
 *       // levels with lower priority. For example: 'error', 'warn' and 'info' will be logged when 'info' level is configured.
 *       //
 *       // Property `logger` represents the logging function which will be invoked for every log call with an acceptable level. The function should
 *       // take two string arguments `level` and `message`. The function should not execute any blocking or long-running operations
 *       // because it is often executed on a hot path.
 *       //
 *       // No logging is done by default. See `neo4j.logging` object that contains predefined logging implementations.
 *       logging: {
 *         level: 'info',
 *         logger: (level, message) => console.log(level + ' ' + message)
 *       },
 *
 *       // Specify a custom server address resolver function used by the routing driver to resolve the initial address used to create the driver.
 *       // Such resolution happens:
 *       //  * during the very first rediscovery when driver is created
 *       //  * when all the known routers from the current routing table have failed and driver needs to fallback to the initial address
 *       //
 *       // In NodeJS environment driver defaults to performing a DNS resolution of the initial address using 'dns' module.
 *       // In browser environment driver uses the initial address as-is.
 *       // Value should be a function that takes a single string argument - the initial address. It should return an array of new addresses.
 *       // Address is a string of shape '<host>:<port>'. Provided function can return either a Promise resolved with an array of addresses
 *       // or array of addresses directly.
 *       resolver: function(address) {
 *         return ['127.0.0.1:8888', 'fallback.db.com:7687'];
 *       },
 *
 *      // Optionally override the default user agent name.
 *       userAgent: USER_AGENT
 *     }
 *
 * @param {string} url The URL for the Neo4j database, for instance "neo4j://localhost" and/or "bolt://localhost"
 * @param {Map<string,string>} authToken Authentication credentials. See {@link auth} for helpers.
 * @param {Object} config Configuration object. See the configuration section above for details.
 * @returns {Driver}
 */

function driver(url, authToken) {
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  assertString(url, 'Bolt URL');
  var parsedUrl = urlUtil.parseDatabaseUrl(url); // Determine entryption/trust options from the URL.

  var routing = false;
  var encrypted = false;
  var trust;

  switch (parsedUrl.scheme) {
    case 'bolt':
      break;

    case 'bolt+s':
      encrypted = true;
      trust = 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES';
      break;

    case 'bolt+ssc':
      encrypted = true;
      trust = 'TRUST_ALL_CERTIFICATES';
      break;

    case 'neo4j':
      routing = true;
      break;

    case 'neo4j+s':
      encrypted = true;
      trust = 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES';
      routing = true;
      break;

    case 'neo4j+ssc':
      encrypted = true;
      trust = 'TRUST_ALL_CERTIFICATES';
      routing = true;
      break;

    default:
      throw new Error("Unknown scheme: ".concat(parsedUrl.scheme));
  } // Encryption enabled on URL, propagate trust to the config.


  if (encrypted) {
    // Check for configuration conflict between URL and config.
    if ('encrypted' in config || 'trust' in config) {
      throw new Error('Encryption/trust can only be configured either through URL or config, not both');
    }

    config.encrypted = ENCRYPTION_ON;
    config.trust = trust;
  } // Sanitize authority token. Nicer error from server when a scheme is set.


  authToken = authToken || {};
  authToken.scheme = authToken.scheme || 'none'; // Use default user agent or user agent specified by user.

  config.userAgent = config.userAgent || USER_AGENT;
  var address = ServerAddress.fromUrl(parsedUrl.hostAndPort);
  var meta = {
    address: address,
    typename: routing ? 'Routing' : 'Direct',
    routing: routing
  };
  return new _driver.Driver(meta, config, createConnectionProviderFunction());

  function createConnectionProviderFunction() {
    if (routing) {
      return function (id, config, log, hostNameResolver) {
        return new _neo4jDriverBoltConnection.RoutingConnectionProvider({
          id: id,
          config: config,
          log: log,
          hostNameResolver: hostNameResolver,
          authToken: authToken,
          address: address,
          userAgent: config.userAgent,
          routingContext: parsedUrl.query
        });
      };
    } else {
      if (!isEmptyObjectOrNull(parsedUrl.query)) {
        throw new Error("Parameters are not supported with none routed scheme. Given URL: '".concat(url, "'"));
      }

      return function (id, config, log) {
        return new _neo4jDriverBoltConnection.DirectConnectionProvider({
          id: id,
          config: config,
          log: log,
          authToken: authToken,
          address: address,
          userAgent: config.userAgent
        });
      };
    }
  }
}

var USER_AGENT = 'neo4j-javascript/' + _version["default"];
=======
 * @param {string} url The URL for the Neo4j database, for instance "neo4j://localhost" and/or "bolt://localhost"
 * @param {Map<string,string>} authToken Authentication credentials. See {@link auth} for helpers.
 * @param {Config} config Configuration object.
 * @returns {Driver}
 */
function driver(url, authToken, config) {
    if (config === void 0) { config = {}; }
    assertString(url, 'Bolt URL');
    var parsedUrl = urlUtil.parseDatabaseUrl(url);
    // Determine encryption/trust options from the URL.
    var routing = false;
    var encrypted = false;
    var trust;
    switch (parsedUrl.scheme) {
        case 'bolt':
            break;
        case 'bolt+s':
            encrypted = true;
            trust = 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES';
            break;
        case 'bolt+ssc':
            encrypted = true;
            trust = 'TRUST_ALL_CERTIFICATES';
            break;
        case 'neo4j':
            routing = true;
            break;
        case 'neo4j+s':
            encrypted = true;
            trust = 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES';
            routing = true;
            break;
        case 'neo4j+ssc':
            encrypted = true;
            trust = 'TRUST_ALL_CERTIFICATES';
            routing = true;
            break;
        default:
            throw new Error("Unknown scheme: ".concat(parsedUrl.scheme));
    }
    // Encryption enabled on URL, propagate trust to the config.
    if (encrypted) {
        // Check for configuration conflict between URL and config.
        if ('encrypted' in config || 'trust' in config) {
            throw new Error('Encryption/trust can only be configured either through URL or config, not both');
        }
        config.encrypted = ENCRYPTION_ON;
        config.trust = trust;
        config.clientCertificate = (0, neo4j_driver_core_1.resolveCertificateProvider)(config.clientCertificate);
    }
    var authTokenManager = createAuthManager(authToken);
    // Use default user agent or user agent specified by user.
    config.userAgent = config.userAgent || USER_AGENT;
    config.boltAgent = neo4j_driver_core_1.internal.boltAgent.fromVersion(version_1.default);
    var address = ServerAddress.fromUrl(parsedUrl.hostAndPort);
    var meta = {
        address: address,
        typename: routing ? 'Routing' : 'Direct',
        routing: routing
    };
    return new driver_1.Driver(meta, config, createConnectionProviderFunction());
    function createConnectionProviderFunction() {
        if (routing) {
            return function (id, config, log, hostNameResolver) {
                return new neo4j_driver_bolt_connection_1.RoutingConnectionProvider({
                    id: id,
                    config: config,
                    log: log,
                    hostNameResolver: hostNameResolver,
                    authTokenManager: authTokenManager,
                    address: address,
                    userAgent: config.userAgent,
                    boltAgent: config.boltAgent,
                    routingContext: parsedUrl.query
                });
            };
        }
        else {
            if (!isEmptyObjectOrNull(parsedUrl.query)) {
                throw new Error("Parameters are not supported with none routed scheme. Given URL: '".concat(url, "'"));
            }
            return function (id, config, log) {
                return new neo4j_driver_bolt_connection_1.DirectConnectionProvider({
                    id: id,
                    config: config,
                    log: log,
                    authTokenManager: authTokenManager,
                    address: address,
                    userAgent: config.userAgent,
                    boltAgent: config.boltAgent
                });
            };
        }
    }
}
exports.driver = driver;
/**
 * Verifies if the driver can reach a server at the given url.
 *
 * @experimental
 * @since 5.0.0
 * @param {string} url The URL for the Neo4j database, for instance "neo4j://localhost" and/or "bolt://localhost"
 * @param {object} config Configuration object. See the {@link driver}
 * @returns {true} When the server is reachable
 * @throws {Error} When the server is not reachable or the url is invalid
 */
function hasReachableServer(url, config) {
    return __awaiter(this, void 0, void 0, function () {
        var nonLoggedDriver;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    nonLoggedDriver = driver(url, { scheme: 'none', principal: '', credentials: '' }, config);
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, , 3, 5]);
                    return [4 /*yield*/, nonLoggedDriver.getNegotiatedProtocolVersion()];
                case 2:
                    _a.sent();
                    return [2 /*return*/, true];
                case 3: return [4 /*yield*/, nonLoggedDriver.close()];
                case 4:
                    _a.sent();
                    return [7 /*endfinally*/];
                case 5: return [2 /*return*/];
            }
        });
    });
}
exports.hasReachableServer = hasReachableServer;
>>>>>>> library-features
/**
 * Object containing predefined logging configurations. These are expected to be used as values of the driver config's `logging` property.
 * @property {function(level: ?string): object} console the function to create a logging config that prints all messages to `console.log` with
 * timestamp, level and message. It takes an optional `level` parameter which represents the maximum log level to be logged. Default value is 'info'.
 */
<<<<<<< HEAD

var logging = {
  console: function (_console) {
    function console(_x) {
      return _console.apply(this, arguments);
    }

    console.toString = function () {
      return _console.toString();
    };

    return console;
  }(function (level) {
    return {
      level: level,
      logger: function logger(level, message) {
        return console.log("".concat(global.Date.now(), " ").concat(level.toUpperCase(), " ").concat(message));
      }
    };
  })
};
/**
 * Object containing constructors for all neo4j types.
 */

exports.logging = logging;
var types = {
  Node: _neo4jDriverCore.Node,
  Relationship: _neo4jDriverCore.Relationship,
  UnboundRelationship: _neo4jDriverCore.UnboundRelationship,
  PathSegment: _neo4jDriverCore.PathSegment,
  Path: _neo4jDriverCore.Path,
  Result: _neo4jDriverCore.Result,
  ResultSummary: _neo4jDriverCore.ResultSummary,
  Record: _neo4jDriverCore.Record,
  Point: _neo4jDriverCore.Point,
  Date: _neo4jDriverCore.Date,
  DateTime: _neo4jDriverCore.DateTime,
  Duration: _neo4jDriverCore.Duration,
  LocalDateTime: _neo4jDriverCore.LocalDateTime,
  LocalTime: _neo4jDriverCore.LocalTime,
  Time: _neo4jDriverCore.Time,
  Integer: _neo4jDriverCore.Integer
};
/**
 * Object containing string constants representing session access modes.
 */

exports.types = types;
var session = {
  READ: _driver.READ,
  WRITE: _driver.WRITE
};
/**
 * Object containing functions to work with {@link Integer} objects.
 */

exports.session = session;
var integer = {
  toNumber: _neo4jDriverCore.toNumber,
  toString: _neo4jDriverCore.toString,
  inSafeRange: _neo4jDriverCore.inSafeRange
};
/**
 * Object containing functions to work with spatial types, like {@link Point}.
 */

exports.integer = integer;
var spatial = {
  isPoint: _neo4jDriverCore.isPoint
};
/**
 * Object containing functions to work with temporal types, like {@link Time} or {@link Duration}.
 */

exports.spatial = spatial;
var temporal = {
  isDuration: _neo4jDriverCore.isDuration,
  isLocalTime: _neo4jDriverCore.isLocalTime,
  isTime: _neo4jDriverCore.isTime,
  isDate: _neo4jDriverCore.isDate,
  isLocalDateTime: _neo4jDriverCore.isLocalDateTime,
  isDateTime: _neo4jDriverCore.isDateTime
};
/**
 * @private
 */

exports.temporal = temporal;
var forExport = {
  driver: driver,
  "int": _neo4jDriverCore["int"],
  isInt: _neo4jDriverCore.isInt,
  isPoint: _neo4jDriverCore.isPoint,
  isDuration: _neo4jDriverCore.isDuration,
  isLocalTime: _neo4jDriverCore.isLocalTime,
  isTime: _neo4jDriverCore.isTime,
  isDate: _neo4jDriverCore.isDate,
  isLocalDateTime: _neo4jDriverCore.isLocalDateTime,
  isDateTime: _neo4jDriverCore.isDateTime,
  integer: integer,
  Neo4jError: _neo4jDriverCore.Neo4jError,
  auth: _neo4jDriverCore.auth,
  logging: logging,
  types: types,
  session: session,
  error: _neo4jDriverCore.error,
  spatial: spatial,
  temporal: temporal,
  Driver: _driver.Driver,
  Session: _neo4jDriverCore.Session,
  Transaction: _neo4jDriverCore.Transaction,
  Result: _neo4jDriverCore.Result,
  RxSession: _sessionRx["default"],
  RxTransaction: _transactionRx["default"],
  RxResult: _resultRx["default"],
  ResultSummary: _neo4jDriverCore.ResultSummary,
  Plan: _neo4jDriverCore.Plan,
  ProfiledPlan: _neo4jDriverCore.ProfiledPlan,
  QueryStatistics: _neo4jDriverCore.QueryStatistics,
  Notification: _neo4jDriverCore.Notification,
  ServerInfo: _neo4jDriverCore.ServerInfo,
  Record: _neo4jDriverCore.Record,
  Node: _neo4jDriverCore.Node,
  Relationship: _neo4jDriverCore.Relationship,
  UnboundRelationship: _neo4jDriverCore.UnboundRelationship,
  Path: _neo4jDriverCore.Path,
  PathSegment: _neo4jDriverCore.PathSegment,
  Point: _neo4jDriverCore.Point,
  Integer: _neo4jDriverCore.Integer,
  Duration: _neo4jDriverCore.Duration,
  LocalTime: _neo4jDriverCore.LocalTime,
  Time: _neo4jDriverCore.Time,
  Date: _neo4jDriverCore.Date,
  LocalDateTime: _neo4jDriverCore.LocalDateTime,
  DateTime: _neo4jDriverCore.DateTime
};
var _default = forExport;
exports["default"] = _default;
=======
var logging = {
    console: function (level) {
        return {
            level: level,
            logger: function (level, message) {
                return console.log("".concat(global.Date.now(), " ").concat(level.toUpperCase(), " ").concat(message));
            }
        };
    }
};
exports.logging = logging;
/**
 * Object containing constructors for all neo4j types.
 */
var types = {
    Node: neo4j_driver_core_1.Node,
    Relationship: neo4j_driver_core_1.Relationship,
    UnboundRelationship: neo4j_driver_core_1.UnboundRelationship,
    PathSegment: neo4j_driver_core_1.PathSegment,
    Path: neo4j_driver_core_1.Path,
    Result: neo4j_driver_core_1.Result,
    EagerResult: neo4j_driver_core_1.EagerResult,
    ResultSummary: neo4j_driver_core_1.ResultSummary,
    Record: neo4j_driver_core_1.Record,
    Point: neo4j_driver_core_1.Point,
    Date: neo4j_driver_core_1.Date,
    DateTime: neo4j_driver_core_1.DateTime,
    Duration: neo4j_driver_core_1.Duration,
    LocalDateTime: neo4j_driver_core_1.LocalDateTime,
    LocalTime: neo4j_driver_core_1.LocalTime,
    Time: neo4j_driver_core_1.Time,
    Integer: neo4j_driver_core_1.Integer
};
exports.types = types;
/**
 * Object containing string constants representing session access modes.
 */
var session = {
    READ: driver_1.READ,
    WRITE: driver_1.WRITE
};
exports.session = session;
/**
 * Object containing functions to work with {@link Integer} objects.
 */
var integer = {
    toNumber: neo4j_driver_core_1.toNumber,
    toString: neo4j_driver_core_1.toString,
    inSafeRange: neo4j_driver_core_1.inSafeRange
};
exports.integer = integer;
/**
 * Object containing functions to work with spatial types, like {@link Point}.
 */
var spatial = {
    isPoint: neo4j_driver_core_1.isPoint
};
exports.spatial = spatial;
/**
 * Object containing functions to work with temporal types, like {@link Time} or {@link Duration}.
 */
var temporal = {
    isDuration: neo4j_driver_core_1.isDuration,
    isLocalTime: neo4j_driver_core_1.isLocalTime,
    isTime: neo4j_driver_core_1.isTime,
    isDate: neo4j_driver_core_1.isDate,
    isLocalDateTime: neo4j_driver_core_1.isLocalDateTime,
    isDateTime: neo4j_driver_core_1.isDateTime
};
exports.temporal = temporal;
/**
 * Object containing functions to work with graph types, like {@link Node} or {@link Relationship}.
 */
var graph = {
    isNode: neo4j_driver_core_1.isNode,
    isPath: neo4j_driver_core_1.isPath,
    isPathSegment: neo4j_driver_core_1.isPathSegment,
    isRelationship: neo4j_driver_core_1.isRelationship,
    isUnboundRelationship: neo4j_driver_core_1.isUnboundRelationship
};
exports.graph = graph;
/**
 * @private
 */
var forExport = {
    authTokenManagers: neo4j_driver_core_1.authTokenManagers,
    driver: driver,
    hasReachableServer: hasReachableServer,
    int: neo4j_driver_core_1.int,
    isInt: neo4j_driver_core_1.isInt,
    isPoint: neo4j_driver_core_1.isPoint,
    isDuration: neo4j_driver_core_1.isDuration,
    isLocalTime: neo4j_driver_core_1.isLocalTime,
    isTime: neo4j_driver_core_1.isTime,
    isDate: neo4j_driver_core_1.isDate,
    isLocalDateTime: neo4j_driver_core_1.isLocalDateTime,
    isDateTime: neo4j_driver_core_1.isDateTime,
    isNode: neo4j_driver_core_1.isNode,
    isPath: neo4j_driver_core_1.isPath,
    isPathSegment: neo4j_driver_core_1.isPathSegment,
    isRelationship: neo4j_driver_core_1.isRelationship,
    isUnboundRelationship: neo4j_driver_core_1.isUnboundRelationship,
    integer: integer,
    Neo4jError: neo4j_driver_core_1.Neo4jError,
    isRetryableError: neo4j_driver_core_1.isRetryableError,
    auth: neo4j_driver_core_1.auth,
    logging: logging,
    types: types,
    session: session,
    routing: neo4j_driver_core_1.routing,
    error: neo4j_driver_core_1.error,
    graph: graph,
    spatial: spatial,
    temporal: temporal,
    Driver: driver_1.Driver,
    Session: neo4j_driver_core_1.Session,
    Transaction: neo4j_driver_core_1.Transaction,
    ManagedTransaction: neo4j_driver_core_1.ManagedTransaction,
    Result: neo4j_driver_core_1.Result,
    EagerResult: neo4j_driver_core_1.EagerResult,
    RxSession: session_rx_1.default,
    RxTransaction: transaction_rx_1.default,
    RxManagedTransaction: transaction_managed_rx_1.default,
    RxResult: result_rx_1.default,
    ResultSummary: neo4j_driver_core_1.ResultSummary,
    Plan: neo4j_driver_core_1.Plan,
    ProfiledPlan: neo4j_driver_core_1.ProfiledPlan,
    QueryStatistics: neo4j_driver_core_1.QueryStatistics,
    Notification: neo4j_driver_core_1.Notification,
    GqlStatusObject: neo4j_driver_core_1.GqlStatusObject,
    ServerInfo: neo4j_driver_core_1.ServerInfo,
    Record: neo4j_driver_core_1.Record,
    Node: neo4j_driver_core_1.Node,
    Relationship: neo4j_driver_core_1.Relationship,
    UnboundRelationship: neo4j_driver_core_1.UnboundRelationship,
    Path: neo4j_driver_core_1.Path,
    PathSegment: neo4j_driver_core_1.PathSegment,
    Point: neo4j_driver_core_1.Point,
    Integer: neo4j_driver_core_1.Integer,
    Duration: neo4j_driver_core_1.Duration,
    LocalTime: neo4j_driver_core_1.LocalTime,
    Time: neo4j_driver_core_1.Time,
    Date: neo4j_driver_core_1.Date,
    LocalDateTime: neo4j_driver_core_1.LocalDateTime,
    DateTime: neo4j_driver_core_1.DateTime,
    bookmarkManager: neo4j_driver_core_1.bookmarkManager,
    resultTransformers: neo4j_driver_core_1.resultTransformers,
    notificationCategory: neo4j_driver_core_1.notificationCategory,
    notificationSeverityLevel: neo4j_driver_core_1.notificationSeverityLevel,
    notificationFilterDisabledCategory: neo4j_driver_core_1.notificationFilterDisabledCategory,
    notificationFilterMinimumSeverityLevel: neo4j_driver_core_1.notificationFilterMinimumSeverityLevel,
    clientCertificateProviders: neo4j_driver_core_1.clientCertificateProviders
};
exports.default = forExport;
>>>>>>> library-features
