<<<<<<< HEAD
import { Operator } from '../Operator';
import { Subscriber } from '../Subscriber';
import { Observable } from '../Observable';
import { OperatorFunction } from '../types';

/**
 * Emits false if the input observable emits any values, or emits true if the
 * input observable completes without emitting any values.
 *
 * <span class="informal">Tells whether any values are emitted by an observable</span>
=======
import { OperatorFunction } from '../types';
import { operate } from '../util/lift';
import { createOperatorSubscriber } from './OperatorSubscriber';

/**
 * Emits `false` if the input Observable emits any values, or emits `true` if the
 * input Observable completes without emitting any values.
 *
 * <span class="informal">Tells whether any values are emitted by an Observable.</span>
>>>>>>> library-features
 *
 * ![](isEmpty.png)
 *
 * `isEmpty` transforms an Observable that emits values into an Observable that
 * emits a single boolean value representing whether or not any values were
 * emitted by the source Observable. As soon as the source Observable emits a
 * value, `isEmpty` will emit a `false` and complete.  If the source Observable
 * completes having not emitted anything, `isEmpty` will emit a `true` and
 * complete.
 *
 * A similar effect could be achieved with {@link count}, but `isEmpty` can emit
 * a `false` value sooner.
 *
 * ## Examples
 *
 * Emit `false` for a non-empty Observable
<<<<<<< HEAD
 * ```javascript
 * import { Subject } from 'rxjs';
 * import { isEmpty } from 'rxjs/operators';
 *
 * const source = new Subject<string>();
 * const result = source.pipe(isEmpty());
 * source.subscribe(x => console.log(x));
 * result.subscribe(x => console.log(x));
=======
 *
 * ```ts
 * import { Subject, isEmpty } from 'rxjs';
 *
 * const source = new Subject<string>();
 * const result = source.pipe(isEmpty());
 *
 * source.subscribe(x => console.log(x));
 * result.subscribe(x => console.log(x));
 *
>>>>>>> library-features
 * source.next('a');
 * source.next('b');
 * source.next('c');
 * source.complete();
 *
<<<<<<< HEAD
 * // Results in:
 * // a
 * // false
 * // b
 * // c
 * ```
 *
 * Emit `true` for an empty Observable
 * ```javascript
 * import { EMPTY } from 'rxjs';
 * import { isEmpty } from 'rxjs/operators';
 *
 * const result = EMPTY.pipe(isEmpty());
 * result.subscribe(x => console.log(x));
 * // Results in:
=======
 * // Outputs
 * // 'a'
 * // false
 * // 'b'
 * // 'c'
 * ```
 *
 * Emit `true` for an empty Observable
 *
 * ```ts
 * import { EMPTY, isEmpty } from 'rxjs';
 *
 * const result = EMPTY.pipe(isEmpty());
 * result.subscribe(x => console.log(x));
 *
 * // Outputs
>>>>>>> library-features
 * // true
 * ```
 *
 * @see {@link count}
 * @see {@link EMPTY}
 *
<<<<<<< HEAD
 * @return {OperatorFunction<T, boolean>} An Observable of a boolean value indicating whether observable was empty or not
 * @method isEmpty
 * @owner Observable
 */

export function isEmpty<T>(): OperatorFunction<T, boolean> {
  return (source: Observable<T>) => source.lift(new IsEmptyOperator());
}

class IsEmptyOperator implements Operator<any, boolean> {
  call (observer: Subscriber<boolean>, source: any): any {
    return source.subscribe(new IsEmptySubscriber(observer));
  }
}

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
class IsEmptySubscriber extends Subscriber<any> {
  constructor(destination: Subscriber<boolean>) {
    super(destination);
  }

  private notifyComplete(isEmpty: boolean): void {
    const destination = this.destination;

    destination.next(isEmpty);
    destination.complete();
  }

  protected _next(value: boolean) {
    this.notifyComplete(false);
  }

  protected _complete() {
    this.notifyComplete(true);
  }
=======
 * @return A function that returns an Observable that emits boolean value
 * indicating whether the source Observable was empty or not.
 */
export function isEmpty<T>(): OperatorFunction<T, boolean> {
  return operate((source, subscriber) => {
    source.subscribe(
      createOperatorSubscriber(
        subscriber,
        () => {
          subscriber.next(false);
          subscriber.complete();
        },
        () => {
          subscriber.next(true);
          subscriber.complete();
        }
      )
    );
  });
>>>>>>> library-features
}
